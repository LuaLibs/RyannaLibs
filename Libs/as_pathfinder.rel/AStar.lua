--[[
'A* Pathfinder (Version 1.82) by Patrick Lester. Used by permission.
'==================================================================
'Last updated 03/15/04

'This file has been converted to BlitzMax by Tricky (Jeroen Broks)
'December 16th, 2008
'It was further adepted by Tricky to make it all work inside a 
'module on June 26th, 2013
'(Please note that the explanations below are directly copied from the
'original .bb file and that they are not fully BMax compatible).

'On August 13th Tricky tried to convert this code into Lua
'In order to make it compatible with Love2D and other Lua based
'engines.


'An article describing A* and this code in particular can be found at:
'http://www.policyalmanac.org/games/aStarTutorial.htm

'If you want to use this AStar Library, you may do so free of charge so 
'long as the author byline (above) is retained. Thank you to CaseyC 
'at the Blitz Forums for suggesting the use of binary heaps for the open 
'list. Email comments and questions to Patrick Lester at 
'pwlester@policyalmanac.org.

'Setup
'-----
'1. Include "includes/aStarLibrary.bb" at the top of your program.

'2. Create an array called WalkAbility(x,y) that contains information
'	about the WalkAbility of each square/tile on your map, with
'	0 = walkable (the default value) and 1 = unwalkable. The array
'	should range from (0,0) in the upper left hand corner to 
'	(mapWidth-1,mapHeight-1) in the bottom right hand corner.

'3. Adjust the following variables at the top of the .declareVariables
'	subroutine below. All three should be made global.
'	- tileSize = the width and height of your square tiles in pixels
'	- mapWidth = the width of your map in tiles = x value in
'		WalkAbility array.
'	- mapHeight = the height of your map in tiles = y value in
'		WalkAbility array.


'Calling the functions
'---------------------
'There are three main functions

'1.	FindPath(unit.unit,targetX,targetY)
'	- unit.unit = unit that is doing the pathfinding
'	- targetX,targetY = location of the target destination (pixel based coordinates)

'	The FindPath() function returns whether a path could be found (1) or
'	if it's nonexistent (2). If there is a path, it stores it in a bank
'	called unit\pathBank.

'2.   CheckPathStepAdvance(unit.unit)
'	This function updates the current path.

'3.	ReadPath(unit.unit)
' 	This function reads the path data generated by FindPath() and returns
'	the x and y coordinates of the next step on the path. They are stored
'	as xPath and yPath. These coordinates are pixel coordinates 
'	on the screen. See the function for more info.

'==========================================================
'DECLARE VARIABLES
'#declareVariables
]]

	WalkableDebug = false -- Debugs WalkAbility
	
	--Adjust these variables to match your map dimensions (see "setup" above)
	tileSize = 1; mapWidth = 101; mapHeight = 101
	
	--[[
	Rem
	'Create needed arrays
	'Global WalkAbility[mapWidth+1+1,mapHeight+1+1] 'array that holds wall/obstacle information	
	Global openlist[mapWidth*mapHeight+2+1] '1 dimensional array holding ID# of open list items
	Global whichlist[mapWidth+1+1,mapHeight+1+1]  '2 dimensional array used to record 
		'whether a cell is on the open list or on the closed list.
	Global OpenX[mapWidth*mapHeight+2+1] '1d array stores the x location of an item on the open list
	Global OpenY[mapWidth*mapHeight+2+1] '1d array stores the y location of an item on the open list
	Global parentX[mapWidth+1+1,mapHeight+1+1] '2d array to store parent of each cell (x)
	Global parentY[mapWidth+1+1,mapHeight+1+1] '2d array to store parent of each cell (y)
	Global fCost[mapWidth*mapHeight+2+1]	'1d array to store F cost of a cell on the open list
	Global gCost[mapWidth+1+1,mapHeight+1+1] 	'2d array to store G cost for each cell.
	Global hCost[mapWidth*mapHeight+2+1]	'1d array to store H cost of a cell on the open list		
	End Rem
	]]
	
	--[[ Global ]]  openlist={} -- 1d array
	--[[ Global ]]  whichlist={} -- 2d array (IMPORTANT!)
	--[[ Global ]]  OpenX={} -- 1d array
	--[[ Global ]]  OpenY={} -- 1d array
	--[[ Global ]]  parentX={} -- 2d array (IMPORTANT!)
	--[[ Global ]]  parentY={} -- 2d array (IMPORTANT!)
	--[[ Global ]]  fCost={} -- 1d array
	--[[ Global ]]  gCost={} -- 2d array (IMPORTANT!)
	--[[ Global ]]  hCost={} -- 1d array
	
	function d2d(array,d1,d2,def) --> This will just allow me to quickly access 2 dimensional arrays, or what was 2d in BlitzMax since Lua doesn't support the practise.
	     if def then 
	        array[d1..","..d2]=def 
	     else 
	        return array[d1..","..d2] 
	     end
	end
	local function blitzbool(a)
	     return a~=nil and a~=false and a>0 and a~=""
	end     
	local Abs=math.abs
	
	
	--Rem
	--bbdoc: This function setup up the max map bounderies. If not set, it's automatically called with parameters 1,101,10
	--End Rem
	function SetUpPathFinder(ts,mw,mh) -- All parmeters must be integers.
	assert(type(ts)=='number',"SetUpPathFinder: Number expected on arg #1 and not "..type(ts))
	assert(type(mw)=='number',"SetUpPathFinder: Number expected on arg #1 and not "..type(ts))
	assert(type(mh)=='number',"SetUpPathFinder: Number expected on arg #1 and not "..type(mh))
	openlist= {} -- New Int[mw*mh+2+1]
	whichlist = {} -- New Int[mw+1+1,mh+1+1]
	OpenX = {} -- New Int[mw*mh+2+1]
	OpenY = {} -- New Int[mw*mh+2+1]
	parentX = {} -- New Int[mw+1+1,mh+1+1]
	parentY = {} -- New Int[mw+1+1,mh+1+1]
	fCost = {} -- New Int[mw*mh+2+1]
	gCost = {} -- New Int[mw+1+1,mh+1+1]
	hCost = {} -- New Int[mw*mh+2+1]
	Mapwidth=mw
	mapheight=mh
	tilesize=ts
	if walkabledebug then print ( "Setting up map "..ts..": "..mw.."x"..mh) end
	end -- The end of a function
	
	SetUpPathFinder(tileSize,mapWidth,mapHeight)
	
	-- Declare constants
	--[[ Global ]]  onClosedList = 10 --'openlist variable	
	--[[ Global ]]  OnOpenList = 0
	--[[ Const ]] notfinished = 0; notstarted = 0; found = 1; nonexistent = 2 -- pathStatus constants 
	--[[ Const ]] walkable = 0; unwalkable = 1 -- WalkAbility array constants

--Private 
local function WalkAbility(X,Y) return PF_Block(X,Y) end -- The end of a function
--Public

function WalkAbilityDebug()
	local o={ [0]= "_", [1]="X" }
	local l= ""
	print("Mapformat: "..Mapwidth.."x"..MapHeight)
	for  y=0 , mapheight do
		for x=0 , mapwidth do
			l=l..o[WalkAbility(X,Y)]
		end -- Next
		print(right("     "..y,5).."> "..l)
		l=""
	end -- next
end -- The end of a function


--[[
'==========================================================
'FIND PATH: This function finds the path and saves it. Non-Blitz users please note,
'the first parameter is a pointer to a user-defined object called a unit, which contains all
'relevant info about the unit in question (its current location, speed, etc.). As an
'object-oriented data structure, types are similar to structs in C.
'	Please note that targetX and targetY are pixel-based coordinates relative to the
'upper left corner of the map, which is 0,0.
]]
function FindPath(unit,targetX,targetY) -- (unit:PathFinderUnit,targetX,targetY)
local startX,startY = 0,0
local NewOpenListItemID = 0
local addedgCost = 0
local temp = 0
local m = 0
local path = 0
local pathX,pathY = 0,0
local tempx = 0
if WalkableDebug then WalkAbilityDebug() end
-- 1.Convert location data (in pixels) to coordinates in the WalkAbility array.
	startX = math.floor(unit.xLoc/tileSize) ; startY = math.floor(unit.yLoc/tileSize)	
	targetX = math.floor(targetX/tileSize) ; targetY = math.floor(targetY/tileSize)

-- 2. Quick Path Checks: Under the some circumstances no path needs to
--    be generated ...

	--If starting location and target are in the same location...
	if startX == targetX and startY == targetY and unit.pathLocation >  0 then return found end
	if startX == targetX and startY == targetY and unit.pathLocation == 0 then return nonexistent end

	-- If target square is unwalkable, return that it's a nonexistent path.
	if WalkAbility(targetX,targetY) == unwalkable then --'Then Goto noPath
		unit.xPath = startX --'startingX
		unit.yPath = startY --'startingY
		return nonexistent
		end -- EndIf

-- '3.	Reset some variables that need to be cleared
	if onClosedList > 1000000 then -- 'occasionally redim whichlist
		--[[ Global ]] whichlist = {} --[[ 2D!!! [mapWidth,mapHeight] ]]; onClosedList = 10
	end --End If	
	onClosedList = onClosedList+2 --'changing the values of OnOpenList and onClosed list is faster than redimming whichlist() array
	OnOpenList = onClosedList-1
	unit.pathLength = notstarted --'i.e, = 0
	unit.pathLocation = notstarted --'i.e, = 0
	d2d(gCost,startX,startY,0) --'reset starting square's G value to 0

--'4.	Add the starting location to the open list of squares to be checked.
	local numberOfopenlistItems = 1
	openlist[1] = 1 -- 'assign it as the top (and currently only) item in the open list, which is maintained as a binary heap (explained below)
	OpenX[1] = startX ; OpenY[1] = startY


--'5.	Do the following until a path is found or deemed nonexistent.
	repeat

	
--'6.	If the open list is not empty, take the first cell off of the list.
--'This is the lowest F cost cell on the open list.
	if numberOfopenlistItems ~= 0 then

	--'Pop the first item off the open list.
	local ParentXval = OpenX[openlist[1]] or 0; 
	local ParentYval = OpenY[openlist[1]] or 0--'record cell coordinates of the item
	d2d(whichlist,ParentXval,ParentYval,onClosedList) --'add the item to the closed list

	--'Open List = Binary Heap: Delete this item from the open list, which
	--'is maintained as a binary heap. For more information on binary heaps, see:
	--'http://www.policyalmanac.org/games/binaryHeaps.htm
	numberOfopenlistItems = numberOfopenlistItems - 1 --'reduce number of open list items by 1	
	openlist[1] = openlist[numberOfopenlistItems+1] --'move the last item in the heap up to slot #1
	local v = 1	
	repeat --'Repeat the following until the new item in slot #1 sinks to its proper spot in the heap.
		local u = v	
		if 2*u+1 <= numberOfopenlistItems then -- 'if both children exist
		 	--'Check if the F cost of the parent is greater than each child.
			--'Select the lowest of the two children.	
			--print(serialize('fCost',fCost),"\n"..serialize('openlist',openlist),"\n",u)
			if fCost[openlist[u]] >= fCost[openlist[2*u]]   then v = 2*u   end
			if fCost[openlist[v]] >= fCost[openlist[2*u+1]] then v = 2*u+1 end
		else
			if 2*u <= numberOfopenlistItems then --'if only child #1 exists
			 	--'Check if the F cost of the parent is greater than child #1	
				if fCost[openlist[u]] >= fCost[openlist[2*u]] then v = 2*u end
			end --End If	
		end -- End If
		if u~=v then--'if parent's F is > one of its children, swap them
			local temp = openlist[u]
			openlist[u] = openlist[v]
			openlist[v] = temp				
		else
			break --exit 'otherwise, exit loop
		end -- End If	
	until false -- Forever

--[[
	
'7.	Check the adjacent squares. (Its "children" -- these path children
	'are similar, conceptually, to the binary heap children mentioned
	'above, but don't confuse them. They are different. Path children
	'are portrayed in Demo 1 with grey pointers pointing toward
	'their parents.) Add these adjacent child squares to the open list
	'for later consideration if appropriate (see various if statements
	'below).
]]
	for b = ParentYval-1 , ParentYval+1 do
	for a = ParentXval-1 , ParentXval+1 do

	--'If not off the map (do this first to avoid array out-of-bounds errors)
	if a ~= -1 and b ~= -1 and a ~= mapWidth and b ~= mapHeight then

	--'If not already on the closed list (items on the closed list have
	--'already been considered and can now be ignored).			
	if d2d(whichlist,a,b) ~= onClosedList then
	
	--'If not a wall/obstacle square.
	if WalkAbility(a,b) ~= unwalkable then
			
	-- 'Don't cut across corners (this is optional)
	local corner = walkable	
	if a == ParentXval-1 then
		if b == ParentYval-1 then
			if WalkAbility(ParentXval-1,ParentYval) == unwalkable or WalkAbility(ParentXval,ParentYval-1) == unwalkable then corner = unwalkable end
		elseif b == ParentYval+1 then
			if WalkAbility(ParentXval,ParentYval+1) == unwalkable or WalkAbility(ParentXval-1,ParentYval) == unwalkable then corner = unwalkable end
		end -- End If
	elseif a == ParentXval+1 then
		if b == ParentYval-1 then
			if WalkAbility(ParentXval,ParentYval-1) == unwalkable or WalkAbility(ParentXval+1,ParentYval) == unwalkable then corner = unwalkable end
		elseif b == ParentYval+1 then
			if WalkAbility(ParentXval+1,ParentYval) == unwalkable or WalkAbility(ParentXval,ParentYval+1) == unwalkable then corner = unwalkable end
		end -- End If
	end -- End If			
	if corner == walkable then
	
	--'If not already on the open list, add it to the open list.			
	if d2d(whichlist,a,b) ~= OnOpenList	then

		--'Create a new open list item in the binary heap.
		NewOpenListItemID = NewOpenListItemID + 1 -- each new item has a unique ID #
		local m = numberOfopenlistItems+1
		openlist[m] = NewOpenListItemID	 --'place the new open list item (actually, its ID#) at the bottom of the heap
		OpenX[NewOpenListItemID] = a ; OpenY[NewOpenListItemID] = b --'record the x and y coordinates of the new item

		--'Figure out its G cost
		if math.abs(a-ParentXval) == 1 and math.abs(b-ParentYval) == 1 then
			addedgCost = 14 --'cost of going to diagonal squares	
		else	
			addedgCost = 10 --'cost of going to non-diagonal squares				
		end --End If
		d2d(gCost,a,b,d2d(gCost,ParentXval,ParentYval)+addedgCost)
			
		--'Figure out its H and F costs and parent
		hCost[openlist[m]] = 10*(math.abs(a - targetX) + math.abs(b - targetY)) --' record the H cost of the new square
		fCost[openlist[m]] = d2d(gCost,a,b) + hCost[openlist[m]] --'record the F cost of the new square
		d2d(parentX,a,b, ParentXval) ; d2d(parentY,a,b, ParentYval)	--'record the parent of the new square	
		
		--[[
		'Move the new open list item to the proper place in the binary heap.
		'Starting at the bottom, successively compare to parent items,
		'swapping as needed until the item finds its place in the heap
		'or bubbles all the way to the top (if it has the lowest F cost).
		]]
		while m ~= 1 do -- 'While item hasn't bubbled to the top (m=1)	
			--'Check if child's F cost is < parent's F cost. If so, swap them.	
			if (fCost[openlist[m]] or 0) <= (fCost[openlist[math.floor(m/2)]] or 0) then
				temp = openlist[m/2]
				openlist[math.floor(m/2)] = openlist[m]
				openlist[m] = temp
				m = math.floor(m/2)
			else
				break --Exit
			end --End If
		end --Wend 
		numberOfopenlistItems = numberOfopenlistItems+1 --'add one to the number of items in the heap

		--'Change whichlist to show that the new item is on the open list.
		d2d(whichlist,a,b, OnOpenList)


--'8.	If adjacent cell is already on the open list, check to see if this 
--	'path to that cell from the starting location is a better one. 
--	'If so, change the parent of the cell and its G and F costs.	
	else --' If whichlist(a,b) = OnOpenList
	
		-- 'Figure out the G cost of this possible new path
		if Abs(a-ParentXval) == 1 and math.abs(b-ParentYval) == 1 then
			addedgCost = 14--'cost of going to diagonal tiles	
		else	
			addedgCost = 10 --'cost of going to non-diagonal tiles				
		end --End If
		local tempgCost = d2d(gCost,ParentXval,ParentYval)+addedgCost
		
		--'If this path is shorter (G cost is lower) then change
		--'the parent cell, G cost and F cost. 		
		if tempgCost < d2d(gCost,a,b) then 	--'if G cost is less,
			d2d(parentX,a,b,ParentXval) 	--'change the square's parent
			d2d(parentY,a,b,ParentYval)
			d2d(gCost,a,b, tempgCost) 	--'change the G cost			

			--[[
			'Because changing the G cost also changes the F cost, if
			'the item is on the open list we need to change the item's
			'recorded F cost and its position on the open list to make
			'sure that we maintain a properly ordered open list.
			]]
			for x = 1 , numberOfopenlistItems do --'look for the item in the heap
			if OpenX[openlist[x]] == a and OpenY[openlist[x]] == b then --'item found
				fCost[openlist[x]] = d2d(gCost,a,b) + hCost[openlist[x]] --'change the F cost
				
				--'See if changing the F score bubbles the item up from it's current location in the heap
				m = x
				while m ~= 1 do --'While item hasn't bubbled to the top (m=1)	
					--'Check if child is < parent. If so, swap them.	
					if (fCost[openlist[m]] )<= (fCost[openlist[math.floor(m/2)]] ) then -- BlitzMax assumes all undefined integers to be 0. Lua everything undefined is 'nil'. I cannot count on it stuff is defined. 
						temp = openlist[m/2]
						openlist[m/2] = openlist[m]
						openlist[m] = temp
						m = math.floor( m/2 ) -- In Blitz m was an int. Lua doesn't know that type, so let's help it to keep it an int!
					else
						break --'Exit 'while/wend
					end --End If
				end --wend
				
				break --Exit 'for x = loop
			end --End If 'If OpenX(openlist(x)) = a
			end --Next 'For x = 1 To numberOfopenlistItems

		end --End If 'If tempgCost < gCost(a,b) Then			

	end -- End If 'If not already on the open list				
	end -- End If 'If corner = walkable
	end -- End If 'If not a wall/obstacle cell.	
	end -- End If 'If not already on the closed list	
	end -- End If 'If not off the map.	
	end -- Next
	end -- Next

--'9.	If open list is empty then there is no path.	
	else
		path = nonExistent ; break --Exit
	end -- End If

	--'If target is added to open list then path has been found.
	if d2d(whichlist,targetX,targetY) == OnOpenList then path = found ; break --[[Exit]] end

	until false --Forever 'repeat until path is found or deemed nonexistent
	
	
--'10.	Save the path if it exists. Copy it to a bank. 
	if path == found then
		
		--'a. Working backwards from the target to the starting location by checking
		--'each cell's parent, figure out the length of the path.
		pathX = targetX ; pathY = targetY	
		repeat
			tempx = d2d(parentX,pathX,pathY)
			pathY = d2d(parentY,pathX,pathY)
			pathX = tempx
			unit.pathLength = unit.pathLength + 1	
		until pathX == startX and pathY == startY
	
--		'b. Resize the data bank to the right size (leave room to store step 0,
--		'which requires storing one more step than the length)
		ResizeBank(unit.pathBank,(unit.pathLength+1)*4)

--		'c. Now copy the path information over to the d--atabank. Since we are
--		'working backwards from the target to the start location, we copy
--		'the information to the data bank in reverse order. The result is
--		'a properly ordered set of path data, from the first step to the
--		'last.	
		pathX = targetX ; pathY = targetY
		local cellPosition = unit.pathLength*4 -- 'start at the end	
		while not (pathX == startX and pathY == startY)	do
			PokeShort(unit.pathBank,cellPosition,pathX) --'store x value	
			PokeShort(unit.pathBank,cellPosition+2,pathY) --'store y value	
			cellPosition = cellPosition - 4 --'work backwards		
			tempx = d2d(parentX,pathX,pathY)
			pathY = d2d(parentY,pathX,pathY)
			pathX = tempx
		end --Wend	
		PokeShort(unit.pathBank,0,startX) --'store starting x value	
		PokeShort(unit.pathBank,2,startY) --'store starting y value

	end --End If 'If path = found Then 


--'11. Return info on whether a path has been found.
	return path --' Returns 1 if a path has been found, 2 if no path exists. 

--[[
--'12.If there is no path to the selected target, set the pathfinder's
--	'xPath and yPath equal to its current location and return that the
--	'path is nonexistent.
--'#noPath
	unit.xPath = startX
	unit.yPath = startY
	return nonexistent
]]
end -- The end of a function
	

--[[
'==========================================================
'READ PATH DATA: These functions read the path data and convert
'it to screen pixel coordinates.
]]
function ReadPath(unit) --(unit:PathFinderUnit)			
	unit.xPath = ReadPathX(unit,unit.pathLocation)
	unit.yPath = ReadPathY(unit,unit.pathLocation)
end -- The end of a function

function ReadPathX(unit,pathLocation) --#(unit:PathFinderUnit,pathLocation)
	if pathLocation <= unit.pathLength then
		local x = PeekShort (unit.pathBank,pathLocation*4)
		return tileSize*x + .5*tileSize --'align w/center of square	
	end --End If
end -- The end of a function	

function ReadPathY(unit,pathLocation) --#(unit:PathFinderUnit,pathLocation)
	if pathLocation <= unit.pathLength then
		local y = PeekShort (unit.pathBank,pathLocation*4+2)
		return tileSize*y + .5*tileSize --'align w/center of square		
	end --End If
end -- The end of a function

--[[
'This function checks whether the unit is close enough to the next
'path node to advance to the next one or, if it is the last path step,
'to stop.
]]
function CheckPathStepAdvance(unit) --(unit:PathFinderUnit)
	if (unit.xLoc == unit.xPath and unit.yLoc == unit.yPath) or unit.pathLocation == 0 then
		if unit.pathLocation == unit.pathLength then
			unit.pathStatus = notstarted	
		else 		
			unit.pathLocation = unit.pathLocation + 1
			ReadPath(unit) --'update xPath and yPath
		end --End If	
	end --End If	
end -- The end of a function


print("This program uses the A* Pathfinder (Version 1.82) by Patrick Lester.")
print("Originally written in Blitz Basic")
print("Converted to Lua by Jeroen Broks")

return true